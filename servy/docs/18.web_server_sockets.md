# Web Server Sockets

## ê°•ì˜ ì£¼ìš” ë‚´ìš©

* erlang ëª¨ë“ˆ ì†Œê°œ
* erlang -> elixir ì½”ë“œ ë³€í™˜ ë°©ë²•
* tcp socket ì‚¬ìš©ë²• ë° loop back ê°œë…

### 1. erlang ëª¨ë“ˆ ì†Œê°œ

* erlang-otp ëŠ” 20ë…„ ì´ìƒ ìƒíƒœê³„ë¥¼ ê°€ì§€ê³  ìˆë‹¤.
* otpëŠ” `open telecom plaform`ì˜ ì•½ìë¡œ ê³ ì„±ëŠ¥, ì‹ ë¢°ì„±, ë‚´êµ¬ì„±, ì¥ì• íšŒë³µì„± ë“±ì—ì„œ ì´ë¯¸ ê²€ì¦ì„ ë°›ì€ í”Œë«í¼ ì´ë‹¤.
* core ë¶€ë¶„ê³¼ elixirì— ì—†ëŠ” ëª¨ë“ˆì€ erlang ëª¨ë“ˆì„ ì°¸ì¡° í•˜ì!
* erlangì˜ ë¬¸ì„œëŠ” https://www.erlang.org/doc/ ì—ì„œ í™•ì¸ ê°€ëŠ¥í•˜ë‹¤.
* erlang gen_tcp ëª¨ë“ˆì€ https://www.erlang.org/doc/man/gen_tcp ì—ì„œ í™•ì¸ ê°€ëŠ¥í•˜ë‹¤.


### 2. erlang -> elixir ì½”ë“œ ë³€í™˜ ë°©ë²•

* erlang atomì€ ì†Œë¬¸ìë¡œ ì‹œì‘í•œë‹¤. ë”°ë¼ì„œ,  ì†Œë¬¸ìëŠ” ì½œë¡ ì„ ë¶™ì—¬ì„œ elixir atomìœ¼ë¡œ ë³€ê²½í•œë‹¤.  
* erlang ì—ì„œ ë³€ìˆ˜ëŠ” ëŒ€ë¬¸ìë¡œ ì‹œì‘í•œë‹¤. ë”°ë¼ì„œ, elixir ì»¨ë²¤ì…˜ì— ë§ë„ë¡ ì†Œë¬¸ìë¡œ ë³€ê²½í•œë‹¤.
* erlang ëª¨ë“ˆì€ ë°˜ë“œì‹œ ì½œë¡ (:)ì„ ë¶™ì—¬ì„œ ì‚¬ìš©í•œë‹¤.
* erlang ëª¨ë“ˆ:í•¨ìˆ˜ í˜•íƒœë¡œ í˜¸ì¶œí•œë‹¤. ë”°ë¼ì„œ, :ëª¨ë“ˆ.í•¨ìˆ˜ í˜•íƒœë¡œ ë³€ê²½í•œë‹¤.

```elixir
#erlang get_tpc ì„œë²„ ì†ŒìŠ¤
#server() ->
#    {ok, LSock} = gen_tcp:listen(5678, [binary, {packet, 0}, 
#                                        {active, false}]),
#    {ok, Sock} = gen_tcp:accept(LSock),
#    {ok, Bin} = do_recv(Sock, []),
#    ok = gen_tcp:close(Sock),
#    ok = gen_tcp:close(LSock),
#    Bin.

# erlang -> elixirë¡œ í¬íŒ…ëœ ì†ŒìŠ¤
def server do
   {:ok, lsock} = :gen_tcp.listen(5678, [:binary, packet: 0, active: false])
   {:ok, sock} = :gen_tcp.accept(lsock)
   {:ok, bin} = :gen_tcp.recv(sock, 0)
   :ok = :gen_tcp.close(sock)
end



#################################
# erlang -> elixirë¡œ ë³€í™˜ ê³¼ì •
#################################
# í•¨ìˆ˜ ì„ ì–¸ë¶€ë¥¼ ë³€ê²½í•œë‹¤.
# server() ->
def server do

# erlang ì†Œë¬¸ì -> elixir atom ìœ¼ë¡œ ã…‚
# ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” ê²ƒì€ ë³€ìˆ˜ì¸ë°, elixir ë„¤ì´ë° ì»¨ë²¤ì…˜ì— ë”°ë¼ ì†Œë¬¸ìë¡œ ë³€ê²½í•œë‹¤.
# erlang ëª¨ë“ˆì€ ì½œë¡ (:)ìœ¼ë¡œ ì‹œì‘í•œë‹¤.  ë˜í•œ, ëª¨ë“ˆì•ˆì˜ í•¨ìˆ˜ëŠ” erlangê³¼ ë‹¤ë¥´ê²Œ ë§ˆì¹¨í‘œ(.)ë¡œ êµ¬ë¶„í•œë‹¤.
# ì˜µì…˜ë¶€ì˜ ì†Œë¬¸ìëŠ” ëª¨ë‘ atomì´ë¯€ë¡œ ì½œë¡ ì„ ë¶™ì¸ë‹¤.
# erlangì—ì„œëŠ” í•¨ìˆ˜ì˜ í•œë¬¸ì¥ì´ ëë‚ ë•Œë§ˆë‹¤ ì»´ë§ˆ(,)ë¥¼ ì¶”ê°€í•œë‹¤. í•˜ì§€ë§Œ elixirì—ì„œëŠ” í•„ìš” ì—†ìœ¼ë¯€ë¡œ ì œê±°í•œë‹¤.
#   {ok, LSock} = gen_tcp:listen(5678, [binary, {packet, 0},
#                                       {active, false}]),

# elixirë¡œ ë³€ê²½ëœ ë¶€ë¶„ (case 1)
    {:ok, lsock} = :gen_tcp.listen(5678, [:binary, {:packet, 0}, {:active, false}])
# í‚¤ì›Œë“œ ë¦¬ìŠ¤íŠ¸ ì´ë¯€ë¡œ pagcket: 0, active: false í˜•íƒœë¡œ ë³€ê²½í•œë‹¤. (case 2)
    {:ok, lsock} = :gen_tcp.listen(5678, [:binary, packet: 0, active: false])

#   {ok, Sock} = gen_tcp:accept(LSock),
   {:ok, sock} = :gen_tcp.accept(lsock)
#   {ok, Bin} = do_recv(Sock, []),
   {:ok, bin} = :gen_tcp.recv(sock, 0)
#   ok = gen_tcp:close(Sock),
   :ok = :gen_tcp.close(sock)

# erlangì—ì„œëŠ” ë§ˆì¹¨í‘œ(.)ê°€ í•¨ìˆ˜ì˜ ëì„ ë‚˜íƒ€ë‚¸ë‹¤.
#   Bin.
end
```

### 3. tcp socket ì‚¬ìš©ë²• ë° loop back ê°œë…

* elixirì—ì„œëŠ” `while(true)ì˜ ê°œë…`ì„ `ì¬ê·€ í˜¸ì¶œ(loop back) ë°©ì‹`ìœ¼ë¡œ í•´ê²°í•œë‹¤.

```elixir
defmodule Servy.HttpServer do

Â  def start(port) when is_integer(port) and port > 1023 do
Â  Â  {:ok, listen_socket} =

Â  Â  Â  :gen_tcp.listen(port, [:binary, packet: :raw, active: false, reuseaddr: true])
Â  Â  IO.puts "\nğŸ§ Â Listening for connection requests on port #{port}...\n"  
Â  Â  
Â  Â  # accept_loop í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ì—¬ listen ì„ ìˆ˜í–‰í•œë‹¤.
Â  Â  accept_loop(listen_socket)
Â  end
  
Â  def accept_loop(listen_socket) do
Â  Â  IO.puts "âŒ›ï¸ Â Waiting to accept a client connection...\n"
Â  Â  {:ok, client_socket} = :gen_tcp.accept(listen_socket)  

Â  Â  IO.puts "âš¡ï¸ Â Connection accepted!\n"  

Â  Â  serve(client_socket)

    # ì™„ë£Œí›„ ë‹¤ì‹œ listen ìƒíƒœë¡œ ëŒì•„ê°€ê¸° ìœ„í•´, ì¬ê·€ í˜¸ì¶œì„ ìˆ˜í–‰í•œë‹¤.
Â  Â  accept_loop(listen_socket)
Â  end

...
...
end
```