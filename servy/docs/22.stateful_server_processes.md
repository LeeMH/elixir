# Stateful Server Processes

## 강의 주요 내용

* stateful 서버 구성
* 

### 1. stateful 서버 구성

* elixir에서는 OOP 처럼 별도의 상태를 공유할 방법이 없다.
* listen_loop에 초기값을 넣고, 해당 값을 메모리 상에서 유지하는 방법으로 처리한다.
![[state관리.png]]

### 2. stateful 서버 예제

```elixir
defmodule Servy.PledgeServer do  
  
  ## 상태유지를 위해 state를 받는다.
  def listen_loop(state) do
    IO.puts "\nWaiting for a message..." 

    receive do
      ## 생성인경우
      {:create_pledge, name, amount} ->
        {:ok, id} = send_pledge_to_servcie(name, amount)
        ## 기존 state 앞에 새로 생성된 pledge를 추가한다.
        new_state = [ {name, amount} | state ]
        IO.puts "#{name} pledged #{amount}!"
        IO.puts "New state is #{inspect new_state}"
        ## 해당 상태를 유지하기 위해, 다시 listen_loop에 해당값을 전달한다.
        listen_loop(new_state)
      ## cache 조회인경우,
      {sender, :recent_pledges} ->
        ## 요청자에게 결과를 돌려주어야 하기때문에, sender(pid)를 받아 send로 결과를 회신한다.
        send sender, {:response, state}
        IO.puts "Sent pledges to #{inspect sender}"
        
        ## 변경이 없지만, 상태를 유지하기 위해 다시 argument로 상태를 전달한다.
        listen_loop(state)
    end
  end

  ...
  ...
end  
```

```elixir
## PledgeServer 시작
## 마지막은 arguement를 list로 넣어야 한다. 첫번째 argument로 empty list를 전달한다.
iex(6)> pid = spawn(Servy.PledgeServer, :listen_loop, [[]])

Waiting for a message...
#PID<0.213.0>

## larry 생성
iex(7)> send pid, {:create_pledge, "larry", 10}
larry pledged 10!
{:create_pledge, "larry", 10}
New state is [{"larry", 10}]

Waiting for a message...

## moe 생성
iex(8)> send pid, {:create_pledge, "moe", 20}
moe pledged 20!
{:create_pledge, "moe", 20}
New state is [{"moe", 20}, {"larry", 10}]

Waiting for a message...

## curly 생성
iex(9)> send pid, {:create_pledge, "curly", 30}
curly pledged 30!
{:create_pledge, "curly", 30}
New state is [{"curly", 30}, {"moe", 20}, {"larry", 10}]

Waiting for a message...

## recent_pledge(cache) 요청
iex(10)> send pid, {self(), :recent_pledges}
Sent pledges to #PID<0.202.0>
{#PID<0.202.0>, :recent_pledges}

Waiting for a message...

## 프로세스간 통신은 메시지 박스를 통해서만 이뤄진다.
## 메세지 박스를 확인하면, 수신된 메시지를 확인할 수 있다.
iex(11)> Process.info(self(), :messages)
{:messages, [response: [{"curly", 30}, {"moe", 20}, {"larry", 10}]]}

## 메세지를 받는다.
iex(12)> receive do {:response, v} -> v end
[{"curly", 30}, {"moe", 20}, {"larry", 10}]
iex(13)> 
```